---
title: "<span style='font-size: 28px'>Single-cell RNAseq of mouse heart development</style>"
date: '`r format(Sys.time(), "%d %B, %Y")`'
output:
  html_document:
    keep_md: true
    fig_width: 5
    fig_height: 5
    fig_caption: yes
    code_folding: hide
    toc: true
    toc_float: 
      collapsed: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(scran)
library(dynamicTreeCut)
library(RColorBrewer)

dir <- "/Users/ibarra01/OneDrive - CRUK Cambridge Institute/github/mouseHeart_earlyDev_atlas/"

palette(brewer.pal(n=12, "Set3"))
```

```{r functions}
## plot expression on t-SNE
bluefunc <- colorRampPalette(c("lightgrey", "dodgerblue4"))
plotGeneOnTSNE <- function(gene, tsne, clusters) {
  id <- row.names(ann[ann$gene == gene,])
  df <- data.frame(x = tsne$x, y = tsne$y, exp = log2(dataNorm[id,row.names(tsne)]+1) )
  df <- df[order(df$exp,decreasing = FALSE),]
  
  par(mfrow=c(1,2),mar=c(8,4,8,4))
  plot(df$x, df$y, pch=16, cex=0.75, xlab="", ylab="", main=gene, col=bluefunc(10)[findInterval(df$exp, seq(min(df$exp), max(df$exp), (max(df$exp)-min(df$exp))/10))], axes=F)
  box(bty="l")
  
  xl <- min(df$x)+abs(min(df$x)/5); xr <- max(df$x)-max(df$x)/5; 
  yt <- min(df$y)-abs(min(df$y)/5); yb <- yt-((max(df$y)-min(df$y))/35); 
  
  rect(head(seq(xl,xr,(xr-xl)/10),-1), yb, tail(seq(xl,xr,(xr-xl)/10),-1), yt,
       col=bluefunc(10), border=bluefunc(10), lwd=0.5, xpd=NA)
  rect(xl,yb,xr,yt, xpd=NA)
  segments(seq(xl,xr,((xr-xl)/5)),yb,seq(xl,xr,((xr-xl)/5)),yb-((max(df$y)-min(df$y))/35), xpd=NA)
  text(seq(xl,xr,((xr-xl)/5)), yb-((max(df$y)-min(df$y))/35)-1, labels = round(seq(min(df$exp), max(df$exp), (max(df$exp)-min(df$exp))/5),1), cex=0.85, xpd=NA)
  text(xl+(xr-xl)/2, yb-((max(df$y)-min(df$y))/35)-3, labels = expression('log'[2]*' counts + 1'), xpd=NA)
  
  par(mar=c(8,6,8,2))
  boxplot(df$exp~clusters[row.names(df)], col=as.character(levels(as.factor(clusters[row.names(df)]))), main=gene, ylab=expression('log'[2]*' counts + 1'), axes=FALSE)
  box(bty="l"); axis(2, las=2)
  text(x = 1:length(unique(clusters[row.names(df)])), y = min(df$exp)-0.5, srt = 45, adj=1, labels = levels(as.factor(clusters[row.names(df)])), xpd = NA)
}
```

We start from the batch corrected, normalised counts produced in the `02_batchCorrection.Rmd` script.

```{r loadData}
## normalised, batch corrected counts
sce.corr <- readRDS(paste0(dir, "data/sce.goodQual.NORM.batchCorrected.Rds"))

## HVGs
hvgs <- read.table(paste0(dir, "results/HVGs_minMean1_FDR0.05.tsv"), stringsAsFactors = FALSE)
hvgs <- hvgs$V1

## UMAP
umap <- read.table(paste0(dir, "results/umapCoords_corrected.tab"))
```

The next step is to cluster the cells to define the cellular diversity of the dataset. We use the distances between cells based on expression of HVGs on the batch corrected data. Clusters are defined through hierarchical clustering and a dynamic tree cut. 

```{r cluster}
## use the distance between cells to identify clusters
dat <- assay(sce.corr)[hvgs,]
test.dist <- dist(t(dat))

## define clusters by hierarchical clustering and dynamic tree cut
test.clust <- hclust(test.dist, method="average")
cut <- cutreeDynamic(test.clust, distM=as.matrix(test.dist), minClusterSize=40, method="hybrid", deepSplit = 1, verbose = 0)
sce.corr$cluster <- cut

names(cut) <- colnames(dat)
write.table(cut, paste0(dir, "results/clusters_average_min40.tsv"), quote = FALSE, sep="\t", col.names = FALSE)

stopifnot(identical(names(cut), row.names(umap)))
umap$cluster <- cut
o <- order(umap$cluster)
plot(umap$x[o], umap$y[o], pch=16, cex=0.75, col=umap$cluster[o], xlab="UMAP - dim1", ylab="UMAP - dim2", bty="l")
```

This procedure results in `r length(unique(cut[cut!=0]))` clusters.

```{r outliers}
table(cut)[-1]
```

Importantly, clusters are comprised of cells from all different batches. 

```{r batchContrib}
tmp <- sce.corr[,-which(sce.corr$cluster==0)]
table(batch=tmp$batch, cluster=tmp$cluster)
# barplot(t(t(table(batch=tmp$batch, cluster=tmp$cluster))/colSums(table(batch=tmp$batch, cluster=tmp$cluster))*100), col=1:12)
```

Finally, we check the QC statistics to make sure that there isn't a cluster that behaves abnormally.

```{r qc, fig.width=10, fig.height=10}
qc <- read.table(paste0(dir, "data/QCstats_allCells.tsv"))
qc <- qc[names(cut[cut!=0]),]

par(mfrow=c(2,2))
boxplot(log10(qc$libSize)~cut[cut!=0], las=2, xlab="cluster", ylab=expression('log'[10]*' library size'), col=1:12)
boxplot(qc$nGenes/1e3~cut[cut!=0], las=2, xlab="cluster", ylab="number of genes expressed x 1000", col=1:12)
boxplot(qc$mit/qc$libSize*100~cut[cut!=0], las=2, xlab="cluster", ylab="% in MT", col=1:12)
boxplot(qc$ercc/qc$libSize*100~cut[cut!=0], las=2, xlab="cluster", ylab="% in ERCC", col=1:12)
```

### Cluster markers {.tabset}

To get an initial idea of the identity of each cluster, we use the `findMarkers` function to identify genes with large fold-changes in a particular cluster compared to the rest.

We filter genes requiring that they are not expressed at high levels in more than 5 clusters (to get fairly specific markers) and that they have large positive fold-changes compared to the other clusters. This results in this many putative marker genes for each cluster:

```{r DEanalysis}
## use normalised counts and block by batch instead of using batch corrected counts
sce <- readRDS(paste0(dir, "data/sce_goodQual.NORM.Rds"))

keep <- rowMeans(dataNorm) > 0.1
markersDE <- findMarkers(sce, groups = cut, block=sce$batch, direction="up", subset.row=keep)
saveRDS(markersDE, file=paste0(dir, "results/markerGenes_clustersFirstLevel.Rds"))


## filter out genes expressed in too many clusters, as these won't be informative markers
iqrs <- matrix(nrow=nrow(dataNorm), ncol=length(unique(cut)))
for(i in 1:length(unique(cut))){
  cells <- names(cut[cut==i])
  iqrs[,i] <- sapply(row.names(dataNorm), function(x) quantile(log2(dataNorm[x,cells]+1), 0.75))
}
colnames(iqrs) <- paste0("cluster",1:12)
row.names(iqrs) <- row.names(dataNorm)
write.table(iqrs, paste0(dir, "results/3rdQuartileExpr_eachCluster.tsv"), quote = FALSE, sep="\t")

counts0.75 <- as.data.frame(t(sapply(row.names(iqrs), function(x) as.numeric(iqrs[x,]>0))))
colnames(counts0.75) <- paste0("cluster",1:12)
write.table(counts0.75, paste0(dir, "results/3rdQuartileExpr_eachCluster_binarised.tsv"), quote = FALSE, sep="\t")

## to retain genes that are quite specific to each cluster we restrict to those with the 3rd quartile greater than 0 in 5 clusters at most
markersDE.sig <- list()
for(i in names(markersDE)){
  markersDE.sig[[i]] <- as.data.frame(markersDE[[i]][markersDE[[i]]$FDR < 0.05,])
  markersDE.sig[[i]] <- markersDE.sig[[i]][rowSums(counts0.75[row.names(markersDE.sig[[i]]),])<6,]
  markersDE.sig[[i]]$count <- sapply(1:nrow(markersDE.sig[[i]]), function(x) sum(markersDE.sig[[i]][x,-c(1:2)]<2)) ## count how many FC are small
}

markersDE.specific <- list()
for(i in names(markersDE.sig)){
  markersDE.specific[[i]] <- markersDE.sig[[i]][markersDE.sig[[i]]$count <= 5,]
  markersDE.specific[[i]] <- markersDE.specific[[i]][order(markersDE.specific[[i]]$count),] ## order by those with fewest small FCs
}
```

Below is the expression of each (up to 20 per cluster):

#### Cluster 1

```{r cluster1, fig.width=10, fig.height=7}
cluster <- 1
for(i in 1:5){
  id <- row.names(markersDE.specific[[cluster]])[i]
  plotGeneOnTSNE(tsne = tsne, clusters = cut, gene = ann[id,1])
}
```

#### Cluster 2

```{r cluster2, fig.width=10, fig.height=7}
cluster <- 2
for(i in 1:5){
  id <- row.names(markersDE.specific[[cluster]])[i]
  plotGeneOnTSNE(tsne = tsne, clusters = cut, gene = ann[id,1])
}
```

#### Cluster 3

```{r cluster3, fig.width=10, fig.height=7}
cluster <- 3
for(i in 1:5){
  id <- row.names(markersDE.specific[[cluster]])[i]
  plotGeneOnTSNE(tsne = tsne, clusters = cut, gene = ann[id,1])
}
```

#### Cluster 4

```{r cluster4, fig.width=10, fig.height=7}
cluster <- 4
for(i in 1:5){
  id <- row.names(markersDE.specific[[cluster]])[i]
  plotGeneOnTSNE(tsne = tsne, clusters = cut, gene = ann[id,1])
}
```

#### Cluster 5

```{r cluster5, fig.width=10, fig.height=7}
cluster <- 5
for(i in 1:5){
  id <- row.names(markersDE.specific[[cluster]])[i]
  plotGeneOnTSNE(tsne = tsne, clusters = cut, gene = ann[id,1])
}
```

#### Cluster 6

```{r cluster6, fig.width=10, fig.height=7}
cluster <- 6
for(i in 1:5){
  id <- row.names(markersDE.specific[[cluster]])[i]
  plotGeneOnTSNE(tsne = tsne, clusters = cut, gene = ann[id,1])
}
```

#### Cluster 7

```{r cluster7, fig.width=10, fig.height=7}
cluster <- 7
for(i in 1:5){
  id <- row.names(markersDE.specific[[cluster]])[i]
  plotGeneOnTSNE(tsne = tsne, clusters = cut, gene = ann[id,1])
}
```

#### Cluster 8

```{r cluster8, fig.width=10, fig.height=7}
cluster <- 8
for(i in 1:5){
  id <- row.names(markersDE.specific[[cluster]])[i]
  plotGeneOnTSNE(tsne = tsne, clusters = cut, gene = ann[id,1])
}
```

#### Cluster 9

```{r cluster9, fig.width=10, fig.height=7}
cluster <- 9
for(i in 1:5){
  id <- row.names(markersDE.specific[[cluster]])[i]
  plotGeneOnTSNE(tsne = tsne, clusters = cut, gene = ann[id,1])
}
```

#### Cluster 10

```{r cluster10, fig.width=10, fig.height=7}
cluster <- 10
for(i in 1:5){
  id <- row.names(markersDE.specific[[cluster]])[i]
  plotGeneOnTSNE(tsne = tsne, clusters = cut, gene = ann[id,1])
}
```

#### Cluster 11

```{r cluster11, fig.width=10, fig.height=7}
cluster <- 11
for(i in 1:5){
  id <- row.names(markersDE.specific[[cluster]])[i]
  plotGeneOnTSNE(tsne = tsne, clusters = cut, gene = ann[id,1])
}
```

#### Cluster 12

```{r cluster12, fig.width=10, fig.height=7}
cluster <- 12
for(i in 1:5){
  id <- row.names(markersDE.specific[[cluster]])[i]
  plotGeneOnTSNE(tsne = tsne, clusters = cut, gene = ann[id,1])
}
```

```{r info}
sessionInfo()
```
